//
// Generated by Bluespec Compiler, version 2023.07-7-g527eaa0b (build 527eaa0b)
//
// On Tue Dec  5 17:25:15 IST 2023
//
//
// Ports:
// Name                         I/O  size props
// RDY_ma_get_inputs              O     1
// mav_return_output              O   128
// RDY_mav_return_output          O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// ma_get_inputs_in1              I    32
// ma_get_inputs_in2              I    32
// ma_get_inputs_in3              I    32
// ma_get_inputs_in4              I    32
// EN_ma_get_inputs               I     1
// EN_mav_return_output           I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mk_bm4(CLK,
	      RST_N,

	      ma_get_inputs_in1,
	      ma_get_inputs_in2,
	      ma_get_inputs_in3,
	      ma_get_inputs_in4,
	      EN_ma_get_inputs,
	      RDY_ma_get_inputs,

	      EN_mav_return_output,
	      mav_return_output,
	      RDY_mav_return_output);
  input  CLK;
  input  RST_N;

  // action method ma_get_inputs
  input  [31 : 0] ma_get_inputs_in1;
  input  [31 : 0] ma_get_inputs_in2;
  input  [31 : 0] ma_get_inputs_in3;
  input  [31 : 0] ma_get_inputs_in4;
  input  EN_ma_get_inputs;
  output RDY_ma_get_inputs;

  // actionvalue method mav_return_output
  input  EN_mav_return_output;
  output [127 : 0] mav_return_output;
  output RDY_mav_return_output;

  // signals for module outputs
  wire [127 : 0] mav_return_output;
  wire RDY_ma_get_inputs, RDY_mav_return_output;

  // register pipe_0_v_rg_0
  reg [31 : 0] pipe_0_v_rg_0;
  wire [31 : 0] pipe_0_v_rg_0$D_IN;
  wire pipe_0_v_rg_0$EN;

  // register pipe_0_v_rg_1
  reg [31 : 0] pipe_0_v_rg_1;
  wire [31 : 0] pipe_0_v_rg_1$D_IN;
  wire pipe_0_v_rg_1$EN;

  // register pipe_0_v_rg_2
  reg [31 : 0] pipe_0_v_rg_2;
  wire [31 : 0] pipe_0_v_rg_2$D_IN;
  wire pipe_0_v_rg_2$EN;

  // register pipe_0_v_rg_3
  reg [31 : 0] pipe_0_v_rg_3;
  wire [31 : 0] pipe_0_v_rg_3$D_IN;
  wire pipe_0_v_rg_3$EN;

  // register pipe_1_v_rg_0
  reg [31 : 0] pipe_1_v_rg_0;
  wire [31 : 0] pipe_1_v_rg_0$D_IN;
  wire pipe_1_v_rg_0$EN;

  // register pipe_1_v_rg_1
  reg [31 : 0] pipe_1_v_rg_1;
  wire [31 : 0] pipe_1_v_rg_1$D_IN;
  wire pipe_1_v_rg_1$EN;

  // register pipe_1_v_rg_2
  reg [31 : 0] pipe_1_v_rg_2;
  wire [31 : 0] pipe_1_v_rg_2$D_IN;
  wire pipe_1_v_rg_2$EN;

  // register pipe_1_v_rg_3
  reg [31 : 0] pipe_1_v_rg_3;
  wire [31 : 0] pipe_1_v_rg_3$D_IN;
  wire pipe_1_v_rg_3$EN;

  // register rg_stage
  reg [1 : 0] rg_stage;
  reg [1 : 0] rg_stage$D_IN;
  wire rg_stage$EN;

  // ports of submodule cae_0
  wire [63 : 0] cae_0$mv_get_sort;
  wire [31 : 0] cae_0$mv_get_sort_a, cae_0$mv_get_sort_b;

  // ports of submodule cae_1
  wire [63 : 0] cae_1$mv_get_sort;
  wire [31 : 0] cae_1$mv_get_sort_a, cae_1$mv_get_sort_b;

  // ports of submodule cae_2
  wire [63 : 0] cae_2$mv_get_sort;
  wire [31 : 0] cae_2$mv_get_sort_a, cae_2$mv_get_sort_b;

  // ports of submodule cae_3
  wire [63 : 0] cae_3$mv_get_sort;
  wire [31 : 0] cae_3$mv_get_sort_a, cae_3$mv_get_sort_b;

  // ports of submodule cae_4
  wire [63 : 0] cae_4$mv_get_sort;
  wire [31 : 0] cae_4$mv_get_sort_a, cae_4$mv_get_sort_b;

  // ports of submodule cae_5
  wire [63 : 0] cae_5$mv_get_sort;
  wire [31 : 0] cae_5$mv_get_sort_a, cae_5$mv_get_sort_b;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_stage_1,
       CAN_FIRE_ma_get_inputs,
       CAN_FIRE_mav_return_output,
       WILL_FIRE_RL_rl_stage_1,
       WILL_FIRE_ma_get_inputs,
       WILL_FIRE_mav_return_output;

  // action method ma_get_inputs
  assign RDY_ma_get_inputs = rg_stage == 2'd0 ;
  assign CAN_FIRE_ma_get_inputs = rg_stage == 2'd0 ;
  assign WILL_FIRE_ma_get_inputs = EN_ma_get_inputs ;

  // actionvalue method mav_return_output
  assign mav_return_output = { cae_4$mv_get_sort, cae_5$mv_get_sort } ;
  assign RDY_mav_return_output = rg_stage == 2'd2 ;
  assign CAN_FIRE_mav_return_output = rg_stage == 2'd2 ;
  assign WILL_FIRE_mav_return_output = EN_mav_return_output ;

  // submodule cae_0
  mk_cae cae_0(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_0$mv_get_sort_a),
	       .mv_get_sort_b(cae_0$mv_get_sort_b),
	       .mv_get_sort(cae_0$mv_get_sort),
	       .RDY_mv_get_sort());

  // submodule cae_1
  mk_cae cae_1(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_1$mv_get_sort_a),
	       .mv_get_sort_b(cae_1$mv_get_sort_b),
	       .mv_get_sort(cae_1$mv_get_sort),
	       .RDY_mv_get_sort());

  // submodule cae_2
  mk_cae cae_2(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_2$mv_get_sort_a),
	       .mv_get_sort_b(cae_2$mv_get_sort_b),
	       .mv_get_sort(cae_2$mv_get_sort),
	       .RDY_mv_get_sort());

  // submodule cae_3
  mk_cae cae_3(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_3$mv_get_sort_a),
	       .mv_get_sort_b(cae_3$mv_get_sort_b),
	       .mv_get_sort(cae_3$mv_get_sort),
	       .RDY_mv_get_sort());

  // submodule cae_4
  mk_cae cae_4(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_4$mv_get_sort_a),
	       .mv_get_sort_b(cae_4$mv_get_sort_b),
	       .mv_get_sort(cae_4$mv_get_sort),
	       .RDY_mv_get_sort());

  // submodule cae_5
  mk_cae cae_5(.CLK(CLK),
	       .RST_N(RST_N),
	       .mv_get_sort_a(cae_5$mv_get_sort_a),
	       .mv_get_sort_b(cae_5$mv_get_sort_b),
	       .mv_get_sort(cae_5$mv_get_sort),
	       .RDY_mv_get_sort());

  // rule RL_rl_stage_1
  assign CAN_FIRE_RL_rl_stage_1 = rg_stage == 2'd1 ;
  assign WILL_FIRE_RL_rl_stage_1 = CAN_FIRE_RL_rl_stage_1 ;

  // register pipe_0_v_rg_0
  assign pipe_0_v_rg_0$D_IN = cae_0$mv_get_sort[63:32] ;
  assign pipe_0_v_rg_0$EN = EN_ma_get_inputs ;

  // register pipe_0_v_rg_1
  assign pipe_0_v_rg_1$D_IN = cae_0$mv_get_sort[31:0] ;
  assign pipe_0_v_rg_1$EN = EN_ma_get_inputs ;

  // register pipe_0_v_rg_2
  assign pipe_0_v_rg_2$D_IN = cae_1$mv_get_sort[63:32] ;
  assign pipe_0_v_rg_2$EN = EN_ma_get_inputs ;

  // register pipe_0_v_rg_3
  assign pipe_0_v_rg_3$D_IN = cae_1$mv_get_sort[31:0] ;
  assign pipe_0_v_rg_3$EN = EN_ma_get_inputs ;

  // register pipe_1_v_rg_0
  assign pipe_1_v_rg_0$D_IN = cae_2$mv_get_sort[63:32] ;
  assign pipe_1_v_rg_0$EN = CAN_FIRE_RL_rl_stage_1 ;

  // register pipe_1_v_rg_1
  assign pipe_1_v_rg_1$D_IN = cae_3$mv_get_sort[63:32] ;
  assign pipe_1_v_rg_1$EN = CAN_FIRE_RL_rl_stage_1 ;

  // register pipe_1_v_rg_2
  assign pipe_1_v_rg_2$D_IN = cae_3$mv_get_sort[31:0] ;
  assign pipe_1_v_rg_2$EN = CAN_FIRE_RL_rl_stage_1 ;

  // register pipe_1_v_rg_3
  assign pipe_1_v_rg_3$D_IN = cae_2$mv_get_sort[31:0] ;
  assign pipe_1_v_rg_3$EN = CAN_FIRE_RL_rl_stage_1 ;

  // register rg_stage
  always@(EN_mav_return_output or EN_ma_get_inputs or WILL_FIRE_RL_rl_stage_1)
  begin
    case (1'b1) // synopsys parallel_case
      EN_mav_return_output: rg_stage$D_IN = 2'd0;
      EN_ma_get_inputs: rg_stage$D_IN = 2'd1;
      WILL_FIRE_RL_rl_stage_1: rg_stage$D_IN = 2'd2;
      default: rg_stage$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign rg_stage$EN =
	     EN_mav_return_output || EN_ma_get_inputs ||
	     WILL_FIRE_RL_rl_stage_1 ;

  // submodule cae_0
  assign cae_0$mv_get_sort_a = ma_get_inputs_in1 ;
  assign cae_0$mv_get_sort_b = ma_get_inputs_in2 ;

  // submodule cae_1
  assign cae_1$mv_get_sort_a = ma_get_inputs_in3 ;
  assign cae_1$mv_get_sort_b = ma_get_inputs_in4 ;

  // submodule cae_2
  assign cae_2$mv_get_sort_a = pipe_0_v_rg_0 ;
  assign cae_2$mv_get_sort_b = pipe_0_v_rg_3 ;

  // submodule cae_3
  assign cae_3$mv_get_sort_a = pipe_0_v_rg_1 ;
  assign cae_3$mv_get_sort_b = pipe_0_v_rg_2 ;

  // submodule cae_4
  assign cae_4$mv_get_sort_a = pipe_1_v_rg_0 ;
  assign cae_4$mv_get_sort_b = pipe_1_v_rg_1 ;

  // submodule cae_5
  assign cae_5$mv_get_sort_a = pipe_1_v_rg_2 ;
  assign cae_5$mv_get_sort_b = pipe_1_v_rg_3 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        pipe_0_v_rg_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_0_v_rg_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_0_v_rg_2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_0_v_rg_3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_1_v_rg_0 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_1_v_rg_1 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_1_v_rg_2 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	pipe_1_v_rg_3 <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_stage <= `BSV_ASSIGNMENT_DELAY 2'd0;
      end
    else
      begin
        if (pipe_0_v_rg_0$EN)
	  pipe_0_v_rg_0 <= `BSV_ASSIGNMENT_DELAY pipe_0_v_rg_0$D_IN;
	if (pipe_0_v_rg_1$EN)
	  pipe_0_v_rg_1 <= `BSV_ASSIGNMENT_DELAY pipe_0_v_rg_1$D_IN;
	if (pipe_0_v_rg_2$EN)
	  pipe_0_v_rg_2 <= `BSV_ASSIGNMENT_DELAY pipe_0_v_rg_2$D_IN;
	if (pipe_0_v_rg_3$EN)
	  pipe_0_v_rg_3 <= `BSV_ASSIGNMENT_DELAY pipe_0_v_rg_3$D_IN;
	if (pipe_1_v_rg_0$EN)
	  pipe_1_v_rg_0 <= `BSV_ASSIGNMENT_DELAY pipe_1_v_rg_0$D_IN;
	if (pipe_1_v_rg_1$EN)
	  pipe_1_v_rg_1 <= `BSV_ASSIGNMENT_DELAY pipe_1_v_rg_1$D_IN;
	if (pipe_1_v_rg_2$EN)
	  pipe_1_v_rg_2 <= `BSV_ASSIGNMENT_DELAY pipe_1_v_rg_2$D_IN;
	if (pipe_1_v_rg_3$EN)
	  pipe_1_v_rg_3 <= `BSV_ASSIGNMENT_DELAY pipe_1_v_rg_3$D_IN;
	if (rg_stage$EN) rg_stage <= `BSV_ASSIGNMENT_DELAY rg_stage$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    pipe_0_v_rg_0 = 32'hAAAAAAAA;
    pipe_0_v_rg_1 = 32'hAAAAAAAA;
    pipe_0_v_rg_2 = 32'hAAAAAAAA;
    pipe_0_v_rg_3 = 32'hAAAAAAAA;
    pipe_1_v_rg_0 = 32'hAAAAAAAA;
    pipe_1_v_rg_1 = 32'hAAAAAAAA;
    pipe_1_v_rg_2 = 32'hAAAAAAAA;
    pipe_1_v_rg_3 = 32'hAAAAAAAA;
    rg_stage = 2'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mk_bm4

