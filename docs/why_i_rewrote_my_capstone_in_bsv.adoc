= Why I rewrote my capstone project in Bluespec System Verilog

Author: Sai Govardhan M C +
Email: sai.govardhan@incoresemi.com

== Introduction

This document outlines the motivation for using Bluespec System Verilog, which
provides high levels of abstraction to rapidly design hardware microarchitecture.

Like most undergraduate students, I started out designing initial digital
logic in Verilog, with reference to coding guidelines from professors, 
coursework, and the link:http://www.sunburst-design.com/papers/[sunburst papers].
Back then, specifying designs dealing with parallelism and concurrency was always a 
challenge due to lower levels of abstraction and regular rework to fix
synthesis-simulation mismatches. 
 
At link:https://incoresemi.com/[InCore], the use of BSV is one of the 
superpowers that enables small teams like ours to specify complex 
hardware intuitively, correctly, and efficiently. 

A year ago, as a novice BSV designer, I decided it would be interesting
and meaningful to contrast the efforts that my team and I spent during our 
capstone project by re-implementing the Multi-Dimensional Sorting Algorithm (MDSA) 
in a High-Level HDL - BSV. 
As an outcome, this blog collates these insights to establish a strong case for teaching
and using BSV at universities.

In this post, I shall be diving into my BSV implementation by explaining 
essential parts of the microarchitecture, the ease of specifying them in BSV, 
and corresponding snippets from the codebase.

More of our work on the taxonomy of sorters, low power methodologies, 
other variants (Hybrid and Odd-Even sorters), and our ASIC implementation results
can be referred to in our published paper 
link:https://ieeexplore.ieee.org/document/10234758[Low Power Multidimensional Sorters using Clock Gating and Index Sorting]. 

My complete MDSA Bitonic Implementation in BSV, along with our legacy 
Verilog implementation, can be found in my 
link:https://github.com/govardhnn/Low_Power_Multidimensional_Sorters[GitHub repository].

== The Compare And Exchange Block

The `Compare And Exchange` (CAE) block is a fundamental building block of Systolic 
Array based Parallel Hardware Sorters which sorts two inputs to an ascending order output.

image::CAE.png[pdfwidth=40%,align=center,title="The Compare and Exchange (CAE) Block"]

- Specify the CAE typedef as a Vector of 2 elements of width `WordLength`:

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_types.bsv[lines==9..9]

- Declare the method ActionValue `mav_get_sort`:

The CAE block checks if `cae_in[0]` is greater than `cae_in[1]` and uses the 
inbuilt Vector to Vector `reverse` function to swap the values.  

[source,BSV]
include::../bsv/MDSA_bitonic/cae.bsv[lines=38..43]


== The Bitonic Sorting Unit

The Bitonic Sorting Unit is a network of 24 such CAE blocks, intricately 
arranged as depicted below. 

This network sorts eight input elements in ascending order at the end of 
six stages.

To read more about the Bitonic Sorting Network, refer to the seminal paper by
Batcher[4].

image::BM8.png[pdfwidth=50%,align=center,title="The Bitonic Merge Sorting Network"]

If you look closely, we can take parts of
the above BM8 architecture and modularize them. 

=== The BM4 sorter

We could modularize a part of this design, the BM4 unit,
by creating an intermediate two-stage, four-input sorter,
and specify the two methods for input and output as follows:

image::BM4.png[pdfwidth=10%,align=center,title="The BM4 sorter Network"]

- Declare a typedef for `BM4` as a vector of 4 inputs of width `WordLength`:

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_types.bsv[lines=11]

- Specify the intermediate pipeline as a register of the BM4 type:

[source,BSV]
include::../bsv/MDSA_bitonic/bm4.bsv[lines=59]

- First stage of sorting with the inputs, by routing the inputs at indices
0 and 3 to CAE-0, and 1 and 2 to CAE-1 block. We use the inbuilt vector function
vec() to combine multiple elements into a vector:

[source,BSV]
include::../bsv/MDSA_bitonic/bm4.bsv[lines=68..71]

- Perform the second stage sorting with the intermediate sorted values by routing the pipeline outputs at indices
0 and 1 to CAE-0, and 2 and 3 to CAE-1 block:

[source,BSV]
include::../bsv/MDSA_bitonic/bm4.bsv[lines=79..80]

- Return the outputs as:

[source,BSV]
include::../bsv/MDSA_bitonic/bm4.bsv[lines=83..83]

=== The BM8 sorter

Now with the abstraction of using a BM4 sorter, we can proceed to design the
complete Bitonic Merge 8 input sorter as follows:

- Instantiate the 5 intermediate register pipelines:

[source,BSV]
include::../bsv/MDSA_bitonic/bm8.bsv[lines=45..45]

- Pass the inputs through the sorting network defined for each stage of the BM8, 
while storing the intermediate values in the above pipeline registers:

- Stage 1:

[source,BSV]
include::../bsv/MDSA_bitonic/bm8.bsv[lines=124..139]

- Stage 2:

Pass the outputs of the first stage to the BM4 sorter, and register their output
for the third stage:

[source,BSV]
include::../bsv/MDSA_bitonic/bm8.bsv[lines=55..56]

[source,BSV]
include::../bsv/MDSA_bitonic/bm8.bsv[lines=64..71]

\... and so on for the remaining stages 4 to 6.

=== The MDSA Algorithm Implementation

The MDSA algorithm efficiently uses Parallel Hardware Sorters (PHSAs) like the Bitonic sorter we earlier designed to specify an architecture that uses eight such units 
to sort 64 elements in 6 stages by only alternating between row and column sorting, and rerouting the order of outputs (ascending/descending).

image::MDSA.png[pdfwidth=50%,align=center,title="The block diagram of the MDSA Architecture"]

==== MDSA Agorithm FSM

image::MDSA_FSM.png[pdfwidth=50%,align=center,title="The FSM that implements the MDS-Algorithm"]

We specify the `MDSA_64` type which is a multidimensional 8x8 vector 

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_types.bsv[lines=17..18]


To create a 64 record register buffer specified as:

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=34]

And use this helper function to send inputs to the MDSA sorter network:

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=15..27]

==== Stage 1: Column Sorting 

- Sending the inputs to the Eight BM8 sorters:

image::MDSA_FSM_P1.png[pdfwidth=50%,align=center,title="The First Phase of the MDSA Algorithm"]

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=40..46]

- Collecting the ascending order of responses

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=52..59]

- Transposing the output: We can use the inbuilt transpose function
in BSV to alternate between the row and column sorting between the phases of the MDSA.

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=62]

==== Stage 2: Row Sorting 

- Sending the inputs to the Eight BM8 sorters:

image::MDSA_FSM_P2.png[pdfwidth=50%,align=center,title="The Second Phase of the MDSA Algorithm"]

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=71..77]

- Collecting the alternating ascending and descending order of responses

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=84..95]

Transposing the output

[source,BSV]
include::../bsv/MDSA_bitonic/mdsa_bitonic.bsv[lines=98]

\... and so on for the remaining stages 3 to 6 as per the MDSA Algorithm FSM.

Ultimately, an ideal test case where all 64 inputs specified in descending order:

```
[MDSA] STARTING MDSA STAGE 1
[MDSA]: STAGE 1 INPUTS:<V <V 'h00000040 'h0000003f 'h0000003e 'h0000003d 'h0000003c 'h0000003b 'h0000003a 'h00000039  > <V 'h00000038 'h00000037 'h00000036 'h00000035 'h00000034 'h00000033 'h00000032 'h00000031  > <V 'h00000030 'h0000002f 'h0000002e 'h0000002d 'h0000002c 'h0000002b 'h0000002a 'h00000029  > <V 'h00000028 'h00000027 'h00000026 'h00000025 'h00000024 'h00000023 'h00000022 'h00000021  > <V 'h00000020 'h0000001f 'h0000001e 'h0000001d 'h0000001c 'h0000001b 'h0000001a 'h00000019  > <V 'h00000018 'h00000017 'h00000016 'h00000015 'h00000014 'h00000013 'h00000012 'h00000011  > <V 'h00000010 'h0000000f 'h0000000e 'h0000000d 'h0000000c 'h0000000b 'h0000000a 'h00000009  > <V 'h00000008 'h00000007 'h00000006 'h00000005 'h00000004 'h00000003 'h00000002 'h00000001  >  >
```

Shall be sorted in 6 stages to ascending order as follows:

```
Final MDSA output: <%h><V <V 'h00000001 'h00000002 'h00000003 'h00000004 'h00000009 'h0000000a 'h0000000b 'h0000000c  > <V 'h00000005 'h00000006 'h00000007 'h00000008 'h0000000d 'h0000000e 'h0000000f 'h00000010  > <V 'h00000011 'h00000012 'h00000013 'h00000014 'h00000019 'h0000001a 'h0000001b 'h0000001c  > <V 'h00000015 'h00000016 'h00000017 'h00000018 'h0000001d 'h0000001e 'h0000001f 'h00000020  > <V 'h00000021 'h00000022 'h00000023 'h00000024 'h00000029 'h0000002a 'h0000002b 'h0000002c  > <V 'h00000025 'h00000026 'h00000027 'h00000028 'h0000002d 'h0000002e 'h0000002f 'h00000030  > <V 'h00000031 'h00000032 'h00000033 'h00000034 'h00000039 'h0000003a 'h0000003b 'h0000003c  > <V 'h00000035 'h00000036 'h00000037 'h00000038 'h0000003d 'h0000003e 'h0000003f 'h00000040  >  >
Verilog simulation finished
```



== Steps to run simulations of the CAE, BM4, BM8 and MDSA_Bitonic in the GitHub Repository

. Clone the repository:

    git clone https://github.com/govardhnn/Low_Power_Multidimensional_Sorters.git

. Navigate the the build directory of the BSV collateral

    cd bsv/build

. Modify the `makefile.inc` to select the module to simulate

For CAE:

    TB_BSV:= cae_testbench

For BM4:

    TB_BSV:= bm4_testbench

For BM8:

    TB_BSV:= bm8_testbench

For MDSA:

    TB_BSV:= mdsa_bitonic_testbench

. To run the simulation with the Bluespec Compiler (bsc):
    
    make all_vsim

The generated verilog can be found in the `verilog_dir` directory

Note: To get a vcd dump of the simulation, rerun the executable with the +bscvcd argument.
Eg.  ./mk_mdsa_bitonic_testbench_vsim +bscvcd
Or, add the +bscvcd flag to the `v_simulate` target in the Makefile

== Comparisons

. Lines of code

In the BSV implementation of the MDSA

== Lines of BSV design code required from the new redesign effort (= 532)

     46 cae.bsv
     87 bm4.bsv
    153 bm8.bsv
    246 mdsa_bitonic.bsv

== Number of lines of Verilog generated from the above BSV (= 1641) 

    66  mk_cae.v
    171 mk_bm4.v
    575 mk_bm8.v
    829 mk_mdsa_bitonic.v 

Note: you can disable the $display statements from being generated in the verilog 
generation phase by removing the define `-D DISPLAY` in the Makefile

== Wait how does the gate-count compare?

You can run a basic yosys synth at the bsv/build

    make yosys_synth

And the synthesis gate count is:
    Number of cells:              90410

For the legacy verilog MDSA implementation:
To run synth of the legacy codebase:

cd `verilog/MDSA_bitonic`

and run:
    yosys -s synth.ys

And the synthesis gate count is:
   Number of cells:             121574

There you go! A reduction in gate-count from 121k to 90k. 
A staggering 25% reduction in number of cells - using a language much abstract, intuitive and efficient. 

== Acknowledgements(TODO)

The block diagrams and drawings to aid the explanation of the CAE, Bitonic and MDSA are from the paper[1], and the legacy Verilog codebase from the team Samahith S A, Manogna R, Hitesh D guided by my UG Professor Dr. Sudeendra Kumar at PES University, Bangalore.

The BSV languare compiler [2] and libraries reference guide from Bluespec(inc)

Initial Work on MDSA [5] and PHSA sorter variants[6]

Much thanks to reviewers ... ... InCore ... 

== References

. link:https://ieeexplore.ieee.org/document/10234758[Low Power Multidimensional Sorters using Clock Gating and Index Sorting, 2023 IEEE International Conference on Electronics, Computing and Communication Technologies (CONECCT)]
. link:https://github.com/B-Lang-org/bsc[The Bluespec Compiler(bsc)]] 
. link:https://github.com/B-Lang-org/bsc?tab=readme-ov-file#documentation[Libraries Reference Guide]
.  K.E. Batcher, “Sorting Networks and Their Applications,” Proc. AFIPS Proc. Spring Joint Computer Conf., pp. 307-314, 1968.
. A. Norollah, et al, "RTHS: A Low-Cost High-Performance Real-Time Hardware Sorter, Using a Multidimensional Sorting Algorithm," in IEEE Transactions on Very Large-Scale Integration (VLSI) Systems, vol. 27, no. 7, pp. 1601-1613, July 2019.
. V. S. Harshini et al, "Design of Hybrid Sorting Unit," 2019 International Conference on Smart Structures and Systems (ICSSS), Chennai, India, 2019, pp. 1-6

